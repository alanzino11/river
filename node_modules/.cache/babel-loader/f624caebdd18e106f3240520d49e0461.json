{"ast":null,"code":"import _regeneratorRuntime from \"/Users/npaul/river/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/npaul/river/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/npaul/river/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/Users/npaul/river/src/VideoChat.js\";\nimport React, { useState, useCallback } from 'react';\nimport Lobby from './Lobby'; //import Room from './Room';\n\n/*\nuseState is a function that takes a single argument, the initial state, \nthen returns array containing the current state and a function to update that state. \ndestructure that array to give us two distinct variables like state and setState. \ntrack the username, room name and token within our component.\n\nimported useState from react and set up states for the username, room name and token:\n*/\n\nvar VideoChat = function VideoChat() {\n  var _useState = useState(''),\n      _useState2 = _slicedToArray(_useState, 2),\n      username = _useState2[0],\n      setUsername = _useState2[1];\n\n  var _useState3 = useState(''),\n      _useState4 = _slicedToArray(_useState3, 2),\n      roomName = _useState4[0],\n      setRoomName = _useState4[1];\n\n  var _useState5 = useState(null),\n      _useState6 = _slicedToArray(_useState5, 2),\n      token = _useState6[0],\n      setToken = _useState6[1];\n\n  var handleUsernameChange = useCallback(function (event) {\n    setUsername(event.target.value);\n  }, []);\n  var handleRoomNameChange = useCallback(function (event) {\n    setRoomName(event.target.value);\n  }, []);\n  /*\n  The handle functions: Every time the handle functions are called they are redefined\n  useCallback is a react hook that allows us to hold static data, if the data is the same\n  between function calls then they won't get redefined\n  takes two arguments, the function to be memoized and an array of the function's dependencies (not used)\n  */\n\n  var handleSubmit = useCallback(\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(event) {\n      var data;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              event.preventDefault();\n              _context.next = 3;\n              return fetch('/video/token', {\n                method: 'POST',\n                body: JSON.stringify({\n                  identity: username,\n                  room: roomName\n                }),\n                headers: {\n                  'Content-Type': 'application/json'\n                }\n              }).then(function (res) {\n                return res.json();\n              });\n\n            case 3:\n              data = _context.sent;\n              setToken(data.token);\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }(), [username, roomName]);\n  /* The function above: When the user submits the form we send the username and room name \n  to the server to get access token to enter room\n  \n  use the fetch API to send the data as JSON to the endpoint, receive and parse the response, \n  then use setToken to store the token in our state. We'll also wrap this function with useCallback too, \n  but in this case the function will depend on the username and roomName, so we add those as the dependencies to useCallback\n  */\n\n  var handleLogout = useCallback(function (event) {\n    setToken(null);\n  }, []);\n  /* For the final function in this component we'll add a logout functionality. This will eject the user from a room and \n  return them to the lobby. To do so we will set the token to null.\n  */\n\n  var render;\n\n  if (token) {\n    render = React.createElement(Room, {\n      roomName: roomName,\n      token: token,\n      handleLogout: handleLogout,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 67\n      },\n      __self: this\n    });\n  } else {\n    render = React.createElement(Lobby, {\n      username: username,\n      roomName: roomName,\n      handleUsernameChange: handleUsernameChange,\n      handleRoomNameChange: handleRoomNameChange,\n      handleSubmit: handleSubmit,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 71\n      },\n      __self: this\n    });\n  }\n\n  return render;\n  /* Above:\n      -render the form with Lobby Component if token is not set\n      -if token is set, then show username, roomname and token information */\n};\n\nexport default VideoChat;","map":{"version":3,"sources":["/Users/npaul/river/src/VideoChat.js"],"names":["React","useState","useCallback","Lobby","VideoChat","username","setUsername","roomName","setRoomName","token","setToken","handleUsernameChange","event","target","value","handleRoomNameChange","handleSubmit","preventDefault","fetch","method","body","JSON","stringify","identity","room","headers","then","res","json","data","handleLogout","render"],"mappings":";;;;AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,WAA1B,QAA6C,OAA7C;AACA,OAAOC,KAAP,MAAkB,SAAlB,C,CACA;;AACA;;;;;;;;;AASA,IAAMC,SAAS,GAAG,SAAZA,SAAY,GAAM;AAAA,kBACUH,QAAQ,CAAC,EAAD,CADlB;AAAA;AAAA,MACfI,QADe;AAAA,MACLC,WADK;;AAAA,mBAEUL,QAAQ,CAAC,EAAD,CAFlB;AAAA;AAAA,MAEfM,QAFe;AAAA,MAELC,WAFK;;AAAA,mBAGIP,QAAQ,CAAC,IAAD,CAHZ;AAAA;AAAA,MAGfQ,KAHe;AAAA,MAGRC,QAHQ;;AAKtB,MAAMC,oBAAoB,GAAGT,WAAW,CAAC,UAAAU,KAAK,EAAI;AAChDN,IAAAA,WAAW,CAACM,KAAK,CAACC,MAAN,CAAaC,KAAd,CAAX;AACD,GAFuC,EAErC,EAFqC,CAAxC;AAIA,MAAMC,oBAAoB,GAAGb,WAAW,CAAC,UAAAU,KAAK,EAAI;AAChDJ,IAAAA,WAAW,CAACI,KAAK,CAACC,MAAN,CAAaC,KAAd,CAAX;AACD,GAFuC,EAErC,EAFqC,CAAxC;AAGF;;;;;;;AAOA,MAAME,YAAY,GAAGd,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA,6BAAC,iBAAMU,KAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAC7BA,cAAAA,KAAK,CAACK,cAAN;AAD6B;AAAA,qBAEVC,KAAK,CAAC,cAAD,EAAiB;AACvCC,gBAAAA,MAAM,EAAE,MAD+B;AAEvCC,gBAAAA,IAAI,EAAEC,IAAI,CAACC,SAAL,CAAe;AACnBC,kBAAAA,QAAQ,EAAElB,QADS;AAEnBmB,kBAAAA,IAAI,EAAEjB;AAFa,iBAAf,CAFiC;AAMvCkB,gBAAAA,OAAO,EAAE;AACP,kCAAgB;AADT;AAN8B,eAAjB,CAAL,CAShBC,IATgB,CASX,UAAAC,GAAG;AAAA,uBAAIA,GAAG,CAACC,IAAJ,EAAJ;AAAA,eATQ,CAFU;;AAAA;AAEvBC,cAAAA,IAFuB;AAY7BnB,cAAAA,QAAQ,CAACmB,IAAI,CAACpB,KAAN,CAAR;;AAZ6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAD;;AAAA;AAAA;AAAA;AAAA,OAa3B,CAACJ,QAAD,EAAWE,QAAX,CAb2B,CAAhC;AAeA;;;;;;;;AAQA,MAAMuB,YAAY,GAAG5B,WAAW,CAAC,UAAAU,KAAK,EAAI;AACtCF,IAAAA,QAAQ,CAAC,IAAD,CAAR;AACD,GAF6B,EAE3B,EAF2B,CAAhC;AAIA;;;;AAKA,MAAIqB,MAAJ;;AACE,MAAItB,KAAJ,EAAW;AACTsB,IAAAA,MAAM,GACF,oBAAC,IAAD;AAAM,MAAA,QAAQ,EAAExB,QAAhB;AAA0B,MAAA,KAAK,EAAEE,KAAjC;AAAwC,MAAA,YAAY,EAAEqB,YAAtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADJ;AAGD,GAJD,MAIO;AACLC,IAAAA,MAAM,GACJ,oBAAC,KAAD;AACG,MAAA,QAAQ,EAAE1B,QADb;AAEG,MAAA,QAAQ,EAAEE,QAFb;AAGG,MAAA,oBAAoB,EAAEI,oBAHzB;AAIG,MAAA,oBAAoB,EAAEI,oBAJzB;AAKG,MAAA,YAAY,EAAEC,YALjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MADF;AASD;;AACD,SAAOe,MAAP;AAGF;;;AAGC,CAzED;;AA2EA,eAAe3B,SAAf","sourcesContent":["import React, { useState, useCallback } from 'react';\nimport Lobby from './Lobby';\n//import Room from './Room';\n/*\nuseState is a function that takes a single argument, the initial state, \nthen returns array containing the current state and a function to update that state. \ndestructure that array to give us two distinct variables like state and setState. \ntrack the username, room name and token within our component.\n\nimported useState from react and set up states for the username, room name and token:\n*/\n\nconst VideoChat = () => {\n  const [username, setUsername] = useState('');\n  const [roomName, setRoomName] = useState('');\n  const [token, setToken] = useState(null);\n\n  const handleUsernameChange = useCallback(event => {\n    setUsername(event.target.value);\n  }, []);\n\n  const handleRoomNameChange = useCallback(event => {\n    setRoomName(event.target.value);\n  }, []);\n/*\nThe handle functions: Every time the handle functions are called they are redefined\nuseCallback is a react hook that allows us to hold static data, if the data is the same\nbetween function calls then they won't get redefined\ntakes two arguments, the function to be memoized and an array of the function's dependencies (not used)\n*/\n\nconst handleSubmit = useCallback(async event => {\n    event.preventDefault();\n    const data = await fetch('/video/token', {\n      method: 'POST',\n      body: JSON.stringify({\n        identity: username,\n        room: roomName\n      }),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then(res => res.json());\n    setToken(data.token);\n  }, [username, roomName]);\n\n/* The function above: When the user submits the form we send the username and room name \nto the server to get access token to enter room\n\nuse the fetch API to send the data as JSON to the endpoint, receive and parse the response, \nthen use setToken to store the token in our state. We'll also wrap this function with useCallback too, \nbut in this case the function will depend on the username and roomName, so we add those as the dependencies to useCallback\n*/\n\nconst handleLogout = useCallback(event => {\n    setToken(null);\n  }, []);\n\n/* For the final function in this component we'll add a logout functionality. This will eject the user from a room and \nreturn them to the lobby. To do so we will set the token to null.\n*/\n  \n\nlet render;\n  if (token) {\n    render = (\n        <Room roomName={roomName} token={token} handleLogout={handleLogout} />\n    );\n  } else {\n    render = (\n      <Lobby\n         username={username}\n         roomName={roomName}\n         handleUsernameChange={handleUsernameChange}\n         handleRoomNameChange={handleRoomNameChange}\n         handleSubmit={handleSubmit}\n      />\n    );\n  }\n  return render;\n\n\n/* Above:\n    -render the form with Lobby Component if token is not set\n    -if token is set, then show username, roomname and token information */\n};\n\nexport default VideoChat;"]},"metadata":{},"sourceType":"module"}